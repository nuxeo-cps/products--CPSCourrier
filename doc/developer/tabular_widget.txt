==============
Tabular Widget
==============

:Revision: $Id$

.. contents:: :depth: 2
.. sectnum::

TabularWidget is a base class that provides the rendering mechanism
and helper methods::

    >>> from Products.CPSCourrier.widgets.tabular import TabularWidget

Like most CPS objects, we need to provide the id in the constructor::

    >>> tab = TabularWidget('spam')
    >>> tab.getId()
    'spam'

Most of widget methods manipulate DataStructure instances::

    >>> from Products.CPSSchemas.DataStructure import DataStructure

It will be convenient for examples to have a pretty printer::

    >>> from pprint import PrettyPrinter
    >>> pretty_print=PrettyPrinter(width=50).pprint

Items lookup parameters
-----------------------

TabularWidget provides the helper method buildFilters to fetch lookup
parameters from datastructure. Subclasses are supposed to base their
queries upon these parameters.

Fetching parameters
~~~~~~~~~~~~~~~~~~~

The datastructure extraction is based on a prefix whose default value
is ``q_``::

    >>> datastructure1 = DataStructure(data = {
    ...              'q_one': 'value',
    ...              'other' : 'to_discard'})
    >>> tab.buildFilters(datastructure1)
    {'one': 'value'}

Empty values get removed by default::

    >>> datastructure2 = DataStructure(data = {'q_one': '',
    ...                                       'q_eggs': 'spam'})
    >>> tab.buildFilters(datastructure2)
    {'eggs': 'spam'}

Empty values can be replaced by a default value if present (postfixed
'_scope' in datastructure)::

    >>> datastructure3 = DataStructure(data = {'q_one': '',
    ...                                       'q_one_scope': [1,2]})

    >>> tab.buildFilters(datastructure3)
    {'one': [1, 2]}

The prefix used is actually a property of the widget::

    >>> tab.manage_changeProperties(filter_prefix='the_prefix_')
    >>> datastructure4 = DataStructure(data = {
    ...              'the_prefix_one': 'value',
    ...              'q_wrong_prefix' : 'to_discard'})
    >>> tab.buildFilters(datastructure4)
    {'one': 'value'}

Let's get back to the default value
    >>> tab.manage_changeProperties(filter_prefix='q_')

Cookie setting
~~~~~~~~~~~~~~

The cookie identifier is given by the 'cookie_id' property on the tabular
widget. If empty, the cookie setting is completely skipped. So let's
set it::

    >>> tab.manage_changeProperties(cookie_id='test_cook', filter_button='go')

To see what the cookie setting does, we'll need to simulate HTTP requests
and read the cookie.

    >>> from Products.CPSCourrier.widgets.tabular import FakeRequestWithCookies
    >>> tab.REQUEST = FakeRequestWithCookies()
    >>> from Products.CPSCourrier.widgets.tabular import unserializeFromCookie

Cookie setting will not be done if request lacks the filter_button::

    >>> res = tab.buildFilters(datastructure1)
    >>> tab.REQUEST.RESPONSE.cookies
    {}

Let's add this to the request, then::

    >>> tab.REQUEST.form['go'] = 1

The cookie holds the interesting part of datastructure, including empty
values & scopes::

    >>> res = tab.buildFilters(datastructure1)
    >>> cookie = tab.REQUEST.RESPONSE.cookies['test_cook']['value']
    >>> unserializeFromCookie(cookie)
    {u'q_one': u'value'}
    >>> res = tab.buildFilters(datastructure2)
    >>> cookie = tab.REQUEST.RESPONSE.cookies['test_cook']['value']
    >>> pretty_print(unserializeFromCookie(cookie))
    {u'q_eggs': u'spam', u'q_one': u''}
    >>> res = tab.buildFilters(datastructure3)
    >>> cookie = tab.REQUEST.RESPONSE.cookies['test_cook']['value']
    >>> pretty_print(unserializeFromCookie(cookie))
    {u'q_one_scope': [1, 2], u'q_one': u''}

Finally we revert to the default value for filter_button::

    >>> tab.manage_changeProperties(filter_button='')


Global column information
-------------------------

At the end of the rendering process, the tabular passes column
information to the rendering method. This information is global in the
sense that it doesn't depend on the displayed items.
It is extracted from the widgets that appear in the row layout and the
datastructure the tabular works on. What the rendering method gets is
the result of application of the ``columnFromWidget`` method to the
list of row widgets.

So let's make a basic widget::

    >>> from Products.CPSSchemas.Widget import CPSWidget
    >>> col_wi = CPSWidget('mycol')

In the simplest case, the **widget instance** itself is the extracted info::

    >>> ds = DataStructure()
    >>> tab.columnFromWidget(col_wi, ds)
    (<CPSWidget at mycol>, False, '', '')

The three other returned values are, respectively

* a boolean telling whether this column is the current sort reference
* additional reference about the sorting process that has been done.
* the GET part of a link to trigger/toggle sorting by this column

For these other values to be set, the column widget has to specify that it's
sortable and on which index (or key) the sort has to be made. This is done by
setting the 'sortable' property on it.

    >>> col_wi.manage_addProperty('sortable', 'myindex', 'str')

*Warning*: this is not a standard CPSWidget property. To
set it via XML GenericSetup configuration, one needs to make its type
explicit, like this::

    <property name="sortable" type="str">myindex</property>


Is the column the sort reference ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is based on info from the datastructure, so it means that some
widget has to take care of this in its prepare method::

    >>> ds = DataStructure()
    >>> ds['q_sort-col'] = 'mycol'
    >>> tab.columnFromWidget(col_wi, ds)[1]
    True
    >>> ds['q_sort-col'] = 'another'
    >>> tab.columnFromWidget(col_wi, ds)[1]
    False

Additional sorting info
~~~~~~~~~~~~~~~~~~~~~~~

This is any information about the sorting that the triggering widget
may have put in the datastructure for the column renderer::

    >>> ds = DataStructure()
    >>> ds['q_sort-col'] = 'mycol'
    >>> ds['q_sort-order'] = 'spiced-lexico'
    >>> tab.columnFromWidget(col_wi, ds)[1:3]
    (True, 'spiced-lexico')

This shouldn't matter, but by default this is the empty string::

    >>> ds = DataStructure()
    >>> ds['q_sort-col'] = 'other'
    >>> ds['q_sort-order'] = 'spiced-lexico'
    >>> tab.columnFromWidget(col_wi, ds)[1:3]
    (False, '')

Link to trigger/toggle sort by this column
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The method now can provide info to build a link that triggers/toggles
sorting on the column::

    >>> tab.columnFromWidget(col_wi, ds)[3]
    '?widget__q_sort-on=myindex&widget__q_sort-col=mycol'

Obviously, this link has then to point to a document that parses that
kind of request. This is what Toggable Criterion Widgets are meant
for. Let's build one and simulate the above request to check this::

    >>> from Products.CPSCourrier.widgets.filter_widgets import\
    ...               CPSToggableCriterionWidget, FakeRequest
    >>> sort_wid = CPSToggableCriterionWidget('q_sort')
    >>> sort_wid.REQUEST = FakeRequest(**{'widget__q_sort-on':'myindex',
    ...                                   'widget__q_sort-col':'mycol'})

We need a DataStructure instance and cheat a bit with it (sorry)::

    >>> other_ds = DataStructure()
    >>> for x in ['q_sort-on', 'q_sort-col', 'q_sort-col']:
    ...     other_ds[x] = None

This is how the Toggable Criterion widget interprets the request and writes to
the datastructure::

    >>> sort_wid.prepare(other_ds)
    >>> pretty_print(other_ds)
    {'q_sort-col': 'mycol', 'q_sort-order': '', 'q_sort-on': 'myindex'}

Options
~~~~~~~

Let's get back to what the tabular widget does. One can change the
prefix of the target widget::

    >>> tab.columnFromWidget(col_wi, ds, sort_wid='PREF')[3]
    '?widget__PREF-on=myindex&widget__PREF-col=mycol'

If the filter_button property is non-empty, we get an additional key
in the built GET request (see the section on buildFilter)

    >>> tab.filter_button = 'filter'
    >>> tab.columnFromWidget(col_wi, ds)[3]
    '?widget__q_sort-on=myindex&widget__q_sort-col=mycol&filter=go'

Batching
--------

  Although most of the batching has to be implemented by concrete
  subclasses, some properties and helpers are defined at the baseclass
  level, to enforce easy switch between concrete implementations.

Properties
~~~~~~~~~~

  :items_per_page: the max number of items to be displayed on a single page.
  :batching_filter_widget: the filter widget used to grab the
  requested page number from query/cookie/datastructure::

  >>> tab.manage_changeProperties(items_per_page=15,
  ...                             batching_filter='b_page')
  >>> tab.items_per_page
  15
  >>> tab.batching_filter
  'b_page'

  The convention is that this number is human-formatteed

  Like the sort info, this has to be put in datastructure by a Filter
  Widget, along with other filter/query params. Hence, the widget must follow
  the same prefix conventions, and we will have the same cookie persistence
  as other params.

Subclasses
~~~~~~~~~~

  The ``listRowDataStructures`` method, implemented by subclasses,
  must return a tuple.

       #. The list or iterator of prepared datastructure for rows
       #. The current page number
       #. The total number of pages

Helpers
~~~~~~~

  The ``filtersToBatchParams`` takes a dict, as produced by ``buildFilters()``
  and returns the corresponding triple (page, start, length), where start is
  in machine format::

  >>> query = {'b_page': '2', 'q_title': 'stuff'}
  >>> tab.filtersToBatchParams(query)
  (2, 15, 15)

  The batching param has been removed from query::

  >>> query
  {'q_title': 'stuff'}
  >>> query = {'b_page': 1}
  >>> tab.filtersToBatchParams(query)
  (1, 0, 15)

  If the batching param is missing, we treat it as first page::

  >>> query = {'other-stuff': 'abc'}
  >>> tab.filtersToBatchParams(query)
  (1, 0, 15)

  Now let's see the effect of changing properties::

  >>> tab.manage_changeProperties(batching_filter='the_b')
  >>> query = {'the_b': '5', 'q_title': 'stuff'}
  >>> tab.filtersToBatchParams(query)
  (5, 60, 15)
  >>> tab.manage_changeProperties(items_per_page=17)
  >>> query = {'the_b': '3', 'q_title': 'stuff'}
  >>> tab.filtersToBatchParams(query)
  (3, 34, 17)

  ``getNbPages()`` is meant to factorize the computation of the number
  of pages::

  >>> tab.manage_changeProperties(items_per_page=20)
  >>> tab.getNbPages(20)
  1
  >>> tab.getNbPages(13)
  1
  >>> tab.getNbPages(21)
  2
  >>> tab.getNbPages(1)
  1
  >>> tab.getNbPages(200)
  10
  >>> tab.getNbPages(0)
  0

Batching gadget
~~~~~~~~~~~~~~~
  As in the case of column information, predigested info is passed to
  the final render method, to be used to render the batching
  gadget. This takes the form of a dict, named 'batching_info'. In
  case there's only one page of results, this dict is set to ``None``.

  :nb_pages: total number of pages (int)
  :current_page: requested page (int)
  :linked_pages: pages to propose a link to (int list)
  :form_key: the key to use in a linke to request a specific page

  The ``linked_pages`` list is deduced from current_page and the
  property ``batching_gadget_pages``. The batching info is computed by
  ``getBatchingInfo()``::

  >>> tab.manage_changeProperties(batching_filter='b_page',
  ...                             batching_gadget_pages=3)
  >>> nb_pages = 12
  >>> current_page = 7
  >>> pretty_print(tab.getBatchingInfo(current_page, nb_pages))
  {'current_page': 7,
   'form_key': 'widget__q_b_page',
   'linked_pages': [4, 5, 6, 7, 8, 9, 10],
   'nb_pages': 12}

  Here's the behaviour with respect to boundaries::

  >>> nb_pages = 8
  >>> current_page = 7
  >>> tab.getBatchingInfo(current_page, nb_pages)['linked_pages']
  [4, 5, 6, 7, 8]
  >>> current_page = 2
  >>> tab.getBatchingInfo(current_page, nb_pages)['linked_pages']
  [1, 2, 3, 4, 5]

.. Emacs
.. Local Variables:
.. mode: rst
.. End:
.. Vim
.. vim: set filetype=rst:


