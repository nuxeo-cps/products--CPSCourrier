==============
Tabular Widget
==============

:Revision: $Id$

.. contents:: :depth: 2
.. sectnum::

TabularWidget is a base class that provides the rendering mechanism
and helper methods::

    >>> from Products.CPSCourrier.widgets.tabular import TabularWidget

Like most CPS objects, we need to provide the id in the constructor::

    >>> tab = TabularWidget('spam')
    >>> tab.getId()
    'spam'

Most of widget methods manipulate DataStructure instances::

    >>> from Products.CPSSchemas.DataStructure import DataStructure

It will be convenient for examples to have a pretty printer::

    >>> from pprint import PrettyPrinter
    >>> pretty_print=PrettyPrinter(width=50).pprint

Items lookup parameters
-----------------------

TabularWidget provides the helper method buildFilters to fetch lookup
parameters from datastructure. Subclasses are supposed to base their
queries upon these parameters.

Fetching parameters
~~~~~~~~~~~~~~~~~~~

The datastructure extraction is based on a prefix whose default value
is 'q_'::

    >>> datastructure1 = DataStructure(data = {
    ...              'q_one': 'value',
    ...              'other' : 'to_discard'})
    >>> tab.buildFilters(datastructure1)
    {'one': 'value'}

Empty values get removed by default::

    >>> datastructure2 = DataStructure(data = {'q_one': '',
    ...                                       'q_eggs': 'spam'})
    >>> tab.buildFilters(datastructure2)
    {'eggs': 'spam'}

Empty values can be replaced by a default value if present (postfixed
'_scope' in datastructure)::

    >>> datastructure3 = DataStructure(data = {'q_one': '',
    ...                                       'q_one_scope': [1,2]})

    >>> tab.buildFilters(datastructure3)
    {'one': [1, 2]}

The prefix used is actually a property of the widget::

    >>> tab.manage_changeProperties(filter_prefix='the_prefix_')
    >>> datastructure4 = DataStructure(data = {
    ...              'the_prefix_one': 'value',
    ...              'q_wrong_prefix' : 'to_discard'})
    >>> tab.buildFilters(datastructure4)
    {'one': 'value'}

Let's get back to the default value
    >>> tab.manage_changeProperties(filter_prefix='q_')

Cookie setting
~~~~~~~~~~~~~~

The cookie identifier is given by the 'cookie_id' property on the tabular
widget. If empty, the cookie setting is completely skipped. So let's
set it::

    >>> tab.manage_changeProperties(cookie_id='test_cook', filter_button='go')

To see what the cookie setting does, we'll need to simulate HTTP requests
and read the cookie.

    >>> from Products.CPSCourrier.widgets.tabular import FakeRequestWithCookies
    >>> tab.REQUEST = FakeRequestWithCookies()
    >>> from Products.CPSCourrier.widgets.tabular import unserializeFromCookie

Cookie setting will not be done if request lacks the filter_button::

    >>> res = tab.buildFilters(datastructure1)
    >>> tab.REQUEST.RESPONSE.cookies
    {}

Let's add this to the request, then::

    >>> tab.REQUEST.form['go'] = 1

The cookie holds the interesting part of datastructure, including empty
values & scopes::

    >>> res = tab.buildFilters(datastructure1)
    >>> cookie = tab.REQUEST.RESPONSE.cookies['test_cook']['value']
    >>> unserializeFromCookie(cookie)
    {u'q_one': u'value'}
    >>> res = tab.buildFilters(datastructure2)
    >>> cookie = tab.REQUEST.RESPONSE.cookies['test_cook']['value']
    >>> pretty_print(unserializeFromCookie(cookie))
    {u'q_eggs': u'spam', u'q_one': u''}
    >>> res = tab.buildFilters(datastructure3)
    >>> cookie = tab.REQUEST.RESPONSE.cookies['test_cook']['value']
    >>> pretty_print(unserializeFromCookie(cookie))
    {u'q_one_scope': [1, 2], u'q_one': u''}

Finally we revert to the default value for filter_button::

    >>> tab.manage_changeProperties(filter_button='')


Global column information
-------------------------

At the end of the rendering process, the tabular passes column
information to the rendering method. It is extracted from the widgets that
are present in the row layout and the datastructure. So let's make a
basic widget::

    >>> from Products.CPSSchemas.Widget import CPSWidget
    >>> col_wi = CPSWidget('mycol')

In the simplest case, the **widget instance** itself is the extracted info::

    >>> ds = DataStructure()
    >>> tab.columnFromWidget(col_wi, ds)
    (<CPSWidget at mycol>, False, '', '')

The three other returned values are, respectively

* a boolean telling whether this column is the current sort reference
* additional reference about the sorting process that has been done.
* the GET part of a link to trigger/toggle sorting by this column

For these other values to be set, the column widget has to specify that it's
sortable and on which index (or key) the sort has to be made. This is done by
setting the 'sortable' property on it.

    >>> col_wi.manage_addProperty('sortable', 'myindex', 'str')

*Warning*: this is not a standard CPSWidget property. To
set it via XML GenericSetup configuration, one needs to make its type
explicit, like this::

    <property name="sortable" type="str">myindex</property>


Is the column the sort reference ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is based on info from the datastructure, so it means that some
widget has to take care of this in its prepare method::

    >>> ds = DataStructure()
    >>> ds['q_sort-col'] = 'mycol'
    >>> tab.columnFromWidget(col_wi, ds)[1]
    True
    >>> ds['q_sort-col'] = 'another'
    >>> tab.columnFromWidget(col_wi, ds)[1]
    False

Additional sorting info
~~~~~~~~~~~~~~~~~~~~~~~

This is any information about the sorting that the triggering widget
may have put in the datastructure for the column renderer::

    >>> ds = DataStructure()
    >>> ds['q_sort-col'] = 'mycol'
    >>> ds['q_sort-order'] = 'spiced-lexico'
    >>> tab.columnFromWidget(col_wi, ds)[1:3]
    (True, 'spiced-lexico')

This shouldn't matter, but by default this is the empty string::

    >>> ds = DataStructure()
    >>> ds['q_sort-col'] = 'other'
    >>> ds['q_sort-order'] = 'spiced-lexico'
    >>> tab.columnFromWidget(col_wi, ds)[1:3]
    (False, '')

Link to trigger/toggle sort by this column
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The method now can provide info to build a link that triggers/toggles
sorting on the column::

    >>> tab.columnFromWidget(col_wi, ds)[3]
    '?widget__q_sort-on=myindex&widget__q_sort-col=mycol'

Obviously, this link has then to point to a document that parses that
kind of request. This is what Toggable Criterion Widgets are meant
for. Let's build one and simulate the above request to check this::

    >>> from Products.CPSCourrier.widgets.filter_widgets import\
    ...               CPSToggableCriterionWidget, FakeRequest
    >>> sort_wid = CPSToggableCriterionWidget('q_sort')
    >>> sort_wid.REQUEST = FakeRequest(**{'widget__q_sort-on':'myindex',
    ...                                   'widget__q_sort-col':'mycol'})

We need a DataStructure instance and cheat a bit with it (sorry)::

    >>> other_ds = DataStructure()
    >>> for x in ['q_sort-on', 'q_sort-col', 'q_sort-col']:
    ...     other_ds[x] = None

This is how the Toggable Criterion widget interprets the request and writes to
the datastructure::

    >>> sort_wid.prepare(other_ds)
    >>> pretty_print(other_ds)
    {'q_sort-col': 'mycol', 'q_sort-order': '', 'q_sort-on': 'myindex'}

Options
~~~~~~~

Let's get back to what the tabular widget does. One can change the
prefix of the target widget::

    >>> tab.columnFromWidget(col_wi, ds, sort_wid='PREF')[3]
    '?widget__PREF-on=myindex&widget__PREF-col=mycol'

If the filter_button property is non-empty, we get an additional key
in the built GET request (see the section on buildFilter)

    >>> tab.filter_button = 'filter'
    >>> tab.columnFromWidget(col_wi, ds)[3]
    '?widget__q_sort-on=myindex&widget__q_sort-col=mycol&filter=go'


.. Emacs
.. Local Variables:
.. mode: rst
.. End:
.. Vim
.. vim: set filetype=rst:


