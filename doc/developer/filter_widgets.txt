==============
Filter Widgets
==============

:Revision: $Id$

.. contents:: :depth: 1
.. sectnum::

This is the developer's documentation for the widgets that manipulate
filtering and sorting for CPSCourrier's dashboards.

The general idea is that these widgets put in datastructure all
elements that tabular widgets, like the Catalog Tabular Widget will
use to perform their lookup of items to display.

The source of data for these widgets is (in ascending priority):

* the datamodel. Typically, this comes from the document or portlet
  used for the whole dashboard and can be used as persistent default
  parameters.
* a cookie. This makes for session-time persistent parameters.
* the request. For example, if one of these widgets is rendered in
  edit mode, along with a submit <input> tag, then submission will
  have the effect of putting new parameters in the datastructure,
  hence triggering a new lookup and rendering of the tabular widgets.

We'll use a fake DataModel throughout in order not to be bothered in
the examples by the numerous security checks that the full-featured
one provides::

    >>> from Products.CPSSchemas.tests.testWidgets import FakeDataModel
    >>> from Products.CPSSchemas.DataStructure import DataStructure

RequestCookieMixin
------------------

  This is a mixin class that provides the preparation of datastructure
  from request and cookie. Widgets that subclass this and a widget
  class can call explicitely the usual prepare methode and the one
  provided by RequestCookieMixin.

  The cookie parsing is optional and depends on the non-emptiness of
  the 'cookie' property.

  We'll need some imports to deal with cookies::

    >>> from Products.CPSCourrier.widgets.tabular import serializeForCookie
    >>> from Products.CPSCourrier.widgets.filter_widgets \
    ...                 import unserializeFromCookie

  And some general widget stuff::

    >>> from Products.CPSSchemas.Widget import widgetname

CPSSelectFilterWidget
---------------------

  This is a widget that subclasses CPSSelectWidget and parses request
  and cookies.

  It also has an additional property, 'defines_scope' (a boolean). If
  this is set to true, it puts the full vocabulary list of adds
  another (key, item) pair in the
  datastructure in case the normal value is empty. This tells the
  query mechanism the full scope of the search, which might be more
  restrictive than no search.
  Also, the additional reject_from_scope property (tokens) specifies
  keys to exclude from the scope. Typical use-case: you want to filter
  based on workflow states, but one of them corresponds to closed files.


CPSToggableCriterionWidget
--------------------------

This widget is meant to trigger/toggle a criterion (typically a sort)
It manipulates three fields, in that order:

#. the criterion (e.g, on what to sort)
#. the token (e.g, how to sort)
#. an additional reference (e.g, where the request comes from).

Namings in the datastructure are based on the following properties:

* criterion_suffix (defaults to '-on')
* token_suffix (defaults to '-order')
* ref_suffix. (defaults to '-col')

    >>> from Products.CPSCourrier.widgets.filter_widgets import\
    ...               CPSToggableCriterionWidget, FakeRequest
    >>> sort_wid = CPSToggableCriterionWidget('Query sort')
    >>> sort_wid.fields = ['crit', 'token', 'ref']

The token possible values are stored as a property, too::

    >>> sort_wid.manage_changeProperties(toggle_tokens=('usual', 'alternate',))

Let's simulate a request::

    >>> sort_wid.REQUEST = FakeRequest(**{'widget__Query sort-on':'myindex',
    ...                                   'widget__Query sort-col':'mycol'})

The widget really needs to start with a datamodel which has the three
mentionned fields, so let's make one and start with empty fields::

    >>> dm = FakeDataModel()
    >>> for x in ['crit', 'token', 'ref']:
    ...     dm[x] = None
    >>> ds = DataStructure(datamodel=dm)

This is how the Toggable Criterion widget interprets the request and writes to
the datastructure::

    >>> sort_wid.prepare(ds)
    >>> from pprint import PrettyPrinter
    >>> pprint=PrettyPrinter(width=50).pprint
    >>> pprint(ds)
    {'Query sort-order': 'usual', 'Query sort-col': 'mycol', 'Query sort-on': 'myindex'}

The request parsing takes place after loading from datamodel and cookie.
If the request's criterion is the same as the one in datastructure after
these two steps, the widget iterates the token (here, sort-order). So let's
fill the datamodel with values that give the same datastructure as the last
one before request parsing::

    >>> dm['crit'] = 'myindex'
    >>> dm['token'] = 'usual'
    >>> sort_wid.prepare(ds)
    >>> pprint(ds)
    {'Query sort-order': 'alternate', 'Query sort-col': 'mycol', 'Query sort-on': 'myindex'}

A change of criterion doesn't toggle but resets the token to its first value::

    >>> sort_wid.REQUEST.form['widget__Query sort-on'] = 'another'
    >>> sort_wid.prepare(ds)
    >>> pprint(ds)
    {'Query sort-order': 'usual', 'Query sort-col': 'mycol', 'Query sort-on': 'another'}

Int Filter Widget
-----------------
The int filter widget passes queries about integer values, together
with how to use them (typically a range type). This is specified in
the widget properties, and is written to datastructure with a suffix.

    >>> from Products.CPSCourrier.widgets.filter_widgets import\
    ...               CPSIntFilterWidget
    >>> widget = CPSIntFilterWidget('the_widget')
    >>> widget.REQUEST = FakeRequest()
    >>> widget.manage_changeProperties(search_range='min', fields=('int',))

Let's make datamodel and datastructure::

    >>> dm = FakeDataModel()
    >>> ds = DataStructure(datamodel=dm)
    >>> dm['int'] = 3

Now let's go through preparation. It is vital for queries that the datastructure
value's type stays an int, and that's a major difference with the usual
Int Widget::

    >>> widget.prepare(ds)
    >>> ds['the_widget']
    3
    >>> ds['the_widget_range']
    'min'

Same must be true with cookies and request form, and they follow the
usual precedence rules::

    >>> widget.manage_changeProperties(cookie_id='cooked')
    >>> cooked = serializeForCookie({'the_widget': 2})
    >>> widget.REQUEST.cookies = {'cooked': cooked}
    >>> widget.prepare(ds)
    >>> ds['the_widget']
    2
    >>> widget.REQUEST.form = {widgetname('the_widget'): '1'}
    >>> widget.prepare(ds)
    >>> ds['the_widget']
    1

.. Emacs
.. Local Variables:
.. mode: rst
.. End:
.. Vim
.. vim: set filetype=rst:
